#!/usr/bin/env python3
"""
 sync_env.py â€“ keep .env.template and Ansible .env.j2 in lock-step.
 ------------------------------------------------------------------
 *   **Diff mode** (default):
     Prints human-friendly summaries of which keys have to be **added** or **removed**
     so the two files converge.  Exit code **0** â‡’ perfectly in sync, **1** â‡’ drift.

 *   **Docs mode** (`--docs`):
     Generates a Markdown table (variable | default | defined-in) at
     `docs/ENVIRONMENT.md` (or a custom path via `--output`).

 *   **Raw unified diff** (`--unified`):
     Falls back to the classic GNU diff format â€“ useful for CI annotations.

 The script relies solely on the Python std-lib and therefore runs everywhere
 Git does.
"""
from __future__ import annotations

import argparse
import datetime as dt
import difflib
import itertools
import pathlib
import re
import sys
import textwrap
from collections import OrderedDict
from typing import Iterable, Mapping

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
TEMPLATE_FILE = pathlib.Path(".env.template")
JINJA_FILE = pathlib.Path("ansible/roles/pocket_lab/templates/.env.j2")
DEFAULT_DOCS_FILE = pathlib.Path("docs/ENVIRONMENT.md")

ENV_LINE_RE = re.compile(r"^\s*([A-Z0-9_]+)\s*=\s*(.*)$")       # KEY=value
SECTION_RE = re.compile(r"^#+\s*(.+?)\s*$")                      # ### Heading

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def parse_env_file(path: pathlib.Path) -> OrderedDict[str, dict]:
    """Return an **ordered** mapping `KEY -> {default, section}`."""
    if not path.exists():
        sys.exit(f"File not found: {path}")

    current_section: str | None = None
    variables: OrderedDict[str, dict] = OrderedDict()

    for raw_line in path.read_text(encoding="utf-8", errors="ignore").splitlines():
        if raw_line.lstrip().startswith("#"):
            section_match = SECTION_RE.match(raw_line)
            if section_match:
                current_section = section_match.group(1).strip()
            continue

        env_match = ENV_LINE_RE.match(raw_line)
        if not env_match:
            continue

        key, default_value = env_match.group(1), env_match.group(2).strip()
        variables[key] = {"default": default_value, "section": current_section}

    return variables


def emit_docs(template_vars: Mapping[str, dict], jinja_vars: Mapping[str, dict], output_file: pathlib.Path) -> None:
    """Write the Markdown reference to *output_file*."""

    header = textwrap.dedent(
        f"""\
        # Environment Variables Reference

        _Generated by `scripts/sync_env.py --docs` on {dt.datetime.utcnow().isoformat()}Z._

        | Variable | Default | Defined-in |
        |----------|---------|-----------|
        """
    )

    combined: OrderedDict[str, dict] = OrderedDict(itertools.chain(template_vars.items(), jinja_vars.items()))
    lines: list[str] = [header]

    for key, meta in combined.items():
        default = meta.get("default", "").replace("|", "\\|")
        defined_in = (
            "template & j2" if key in template_vars and key in jinja_vars else
            "template"      if key in template_vars               else
            "j2"
        )
        lines.append(f"| {key} | {default} | {defined_in} |")

    output_file.parent.mkdir(parents=True, exist_ok=True)
    output_file.write_text("\n".join(lines) + "\n", encoding="utf-8")
    print(f"ðŸ“„ Documentation written to {output_file}")


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ CLI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€-

def main(argv: list[str] | None = None) -> int:  # noqa: C901 â€“ complex but clear
    parser = argparse.ArgumentParser(description="Synchronise .env templates")
    parser.add_argument("--docs", action="store_true", help="Generate docs/ENVIRONMENT.md and exit")
    parser.add_argument("--output", "-o", type=pathlib.Path, default=DEFAULT_DOCS_FILE,
                        help="Target path for --docs (default: docs/ENVIRONMENT.md)")
    parser.add_argument("--unified", action="store_true", help="Print a raw unified diff instead of the annotated list")
    args = parser.parse_args(argv)

    template_vars = parse_env_file(TEMPLATE_FILE)
    jinja_vars = parse_env_file(JINJA_FILE)

    if args.docs:
        emit_docs(template_vars, jinja_vars, args.output)
        return 0

    template_keys = set(template_vars)
    jinja_keys = set(jinja_vars)

    missing_in_template = sorted(jinja_keys - template_keys)
    missing_in_jinja = sorted(template_keys - jinja_keys)

    if not missing_in_template and not missing_in_jinja:
        print(f"âœ” Environment files are in sync ({len(template_keys)} keys)")
        return 0

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Drift detected â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if args.unified:
        diff_lines = difflib.unified_diff(
            list(template_keys),
            list(jinja_keys),
            fromfile=str(TEMPLATE_FILE),
            tofile=str(JINJA_FILE),
            lineterm="",
        )
        print("\n".join(diff_lines))
    else:
        print("\nâš  Drift detected â€“ bring the files back in sync:\n")
        if missing_in_template:
            print("â€¢ Add the following keys **to .env.template** (present in .env.j2 only):")
            for key in missing_in_template:
                print(f"  â”œâ”€ {key}")
            print()
        if missing_in_jinja:
            print("â€¢ Add the following keys **to .env.j2** (present in .env.template only):")
            for key in missing_in_jinja:
                print(f"  â”œâ”€ {key}")
            print()
        print("Hint: run with --unified for a patch-style diff or --docs to regenerate the reference table.")

    return 1  # Not in sync


if __name__ == "__main__":
    sys.exit(main())
