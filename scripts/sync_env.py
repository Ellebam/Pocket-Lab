#!/usr/bin/env python3
"""
 sync_env.py â€“ keep .env.template and Ansible .env.j2 in lock-step.
 ------------------------------------------------------------------
 *   **Diff mode** (default):
     Prints human-friendly summaries of which keys have to be **added** or **removed**
     so the two files converge.  Exit code **0** â‡’ perfectly in sync, **1** â‡’ drift.

 *   **Docs mode** (`--docs`):
     Generates a Markdown table (variable | default | defined-in) at
     `docs/ENVIRONMENT.md` (or a custom path via `--output`).

 *   **Raw unified diff** (`--unified`):
     Falls back to the classic GNU diff format â€“ useful for CI annotations.

 The script relies solely on the Python std-lib and therefore runs everywhere
 Git does.
"""
from __future__ import annotations

import argparse
import datetime as dt
import difflib
import itertools
import pathlib
import re
import sys
import textwrap
from collections import OrderedDict
from typing import Iterable, Mapping

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
TEMPLATE_FILE = pathlib.Path(".env.template")
JINJA_FILE = pathlib.Path("ansible/roles/pocket_lab/templates/.env.j2")
DEFAULT_DOCS_FILE = pathlib.Path("docs/ENVIRONMENT.md")
TABLE_HEADERS = ["Variable", "Default", "Defined-in" ]

ENV_LINE_RE = re.compile(r"^\s*([A-Z0-9_]+)\s*=\s*(.*)$")       # KEY=value
SECTION_RE = re.compile(r"^#+\s*(.+?)\s*$")                      # ### Heading

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def escape_for_markdown(cell_value: str | None) -> str:
    """Escape pipes and normalize newlines for GFM tables."""
    if cell_value is None:
        return ""
    text = str(cell_value)
    text = text.replace("|", "&#124;")
    text = text.replace("\r\n", "\n").replace("\r", "\n").replace("\n", "<br>")
    return text


def validate_table_shape(headers: list[str], rows: list[list[str]]) -> None:
    """Fail early if a row has a different column count than the header."""
    expected_columns = len(headers)
    for index, row in enumerate(rows, start=1):
        if len(row) != expected_columns:
            raise ValueError(
                f"Row {index} has {len(row)} columns; expected {expected_columns}. Row: {row!r}"
            )


def render_table(headers: list[str], rows: list[list[str]]) -> str:
    """Emit a GitHub-proof Markdown table with blank lines around it."""
    validate_table_shape(headers, rows)
    lines: list[str] = []
    lines.append("")  # blank line BEFORE table
    lines.append("| " + " | ".join(escape_for_markdown(h) for h in headers) + " |")
    lines.append("| " + " | ".join("---" for _ in headers) + " |")
    for row in rows:
        cells = [escape_for_markdown(c) for c in row]
        lines.append("| " + " | ".join(cells) + " |")
    lines.append("")  # blank line AFTER table
    return "\n".join(lines)



def parse_env_file(path: pathlib.Path) -> OrderedDict[str, dict]:
    """Return an **ordered** mapping `KEY -> {default, section}`."""
    if not path.exists():
        sys.exit(f"File not found: {path}")

    current_section: str | None = None
    variables: OrderedDict[str, dict] = OrderedDict()

    for raw_line in path.read_text(encoding="utf-8", errors="ignore").splitlines():
        if raw_line.lstrip().startswith("#"):
            section_match = SECTION_RE.match(raw_line)
            if section_match:
                current_section = section_match.group(1).strip()
            continue

        env_match = ENV_LINE_RE.match(raw_line)
        if not env_match:
            continue

        key, default_value = env_match.group(1), env_match.group(2).strip()
        variables[key] = {"default": default_value, "section": current_section}

    return variables


def emit_docs(
    template_vars: Mapping[str, dict],
    jinja_vars: Mapping[str, dict],
    output_file: pathlib.Path,
) -> None:
    """Write the Markdown reference to *output_file* with robust GFM rendering."""
    header_block = textwrap.dedent(
        f"""\
        # Environment Variables Reference

        _Generated by `scripts/sync_env.py --docs` on {dt.datetime.utcnow().isoformat()}Z._
        """
    )

    # Preserve .env.template order; append j2-only keys after.
    combined: OrderedDict[str, dict] = OrderedDict()
    for key, meta in template_vars.items():
        combined[key] = meta
    for key, meta in jinja_vars.items():
        if key not in combined:
            combined[key] = meta

    table_rows: list[list[str]] = []
    for key, meta in combined.items():
        default_value = meta.get("default", "")
        defined_in = (
            "template & j2"
            if key in template_vars and key in jinja_vars
            else "template"
            if key in template_vars
            else "j2"
        )
        table_rows.append([key, str(default_value), defined_in])

    markdown = header_block + "\n" + render_table(TABLE_HEADERS, table_rows) + "\n"
    output_file.parent.mkdir(parents=True, exist_ok=True)
    output_file.write_text(markdown, encoding="utf-8")
    print(f"ðŸ“„ Documentation written to {output_file}")



# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ CLI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€-

def main(argv: list[str] | None = None) -> int:  # noqa: C901 â€“ complex but clear
    parser = argparse.ArgumentParser(description="Synchronise .env templates")
    parser.add_argument("--docs", action="store_true", help="Generate docs/ENVIRONMENT.md and exit")
    parser.add_argument("--output", "-o", type=pathlib.Path, default=DEFAULT_DOCS_FILE,
                        help="Target path for --docs (default: docs/ENVIRONMENT.md)")
    parser.add_argument("--unified", action="store_true", help="Print a raw unified diff instead of the annotated list")
    args = parser.parse_args(argv)

    template_vars = parse_env_file(TEMPLATE_FILE)
    jinja_vars = parse_env_file(JINJA_FILE)

    if args.docs:
        emit_docs(template_vars, jinja_vars, args.output)
        return 0

    template_keys = set(template_vars)
    jinja_keys = set(jinja_vars)

    missing_in_template = sorted(jinja_keys - template_keys)
    missing_in_jinja = sorted(template_keys - jinja_keys)

    if not missing_in_template and not missing_in_jinja:
        print(f"âœ” Environment files are in sync ({len(template_keys)} keys)")
        return 0

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Drift detected â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if args.unified:
        diff_lines = difflib.unified_diff(
            list(template_keys),
            list(jinja_keys),
            fromfile=str(TEMPLATE_FILE),
            tofile=str(JINJA_FILE),
            lineterm="",
        )
        print("\n".join(diff_lines))
    else:
        print("\nâš  Drift detected â€“ bring the files back in sync:\n")
        if missing_in_template:
            print("â€¢ Add the following keys **to .env.template** (present in .env.j2 only):")
            for key in missing_in_template:
                print(f"  â”œâ”€ {key}")
            print()
        if missing_in_jinja:
            print("â€¢ Add the following keys **to .env.j2** (present in .env.template only):")
            for key in missing_in_jinja:
                print(f"  â”œâ”€ {key}")
            print()
        print("Hint: run with --unified for a patch-style diff or --docs to regenerate the reference table.")

    return 1  # Not in sync


if __name__ == "__main__":
    sys.exit(main())
